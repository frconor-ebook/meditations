import json
import os
import random
import re
import string
import time
from datetime import datetime
from typing import List, Tuple

import requests
from dotenv import load_dotenv
from google import genai
from google.genai import types
from openpyxl import Workbook
from openpyxl.styles import Font

# Rate limiting: Gemini API has a quota of 10 requests per minute
GEMINI_RATE_LIMIT_DELAY = 7  # seconds between requests


class AliasCollisionError(Exception):
    """Raised when TinyURL alias already exists."""
    pass


# --- TinyURL Functions ---
def shorten_url_tinyurl_api(
    long_url: str, api_token: str, custom_alias: str = None
) -> str:
    """Shortens a URL using the TinyURL API.

    Args:
        long_url: The long URL to shorten.
        api_token: Your TinyURL API token.
        custom_alias: (Optional) A custom alias for the URL.

    Returns:
        The shortened URL, or None if an error occurred.

    Raises:
        AliasCollisionError: If the custom alias already exists.
    """
    api_url = "https://api.tinyurl.com/create"
    headers = {
        "Authorization": f"Bearer {api_token}",
        "Content-Type": "application/json",
    }

    payload = {"url": long_url, "domain": "tinyurl.com", "alias": custom_alias}

    try:
        response = requests.post(api_url, headers=headers, data=json.dumps(payload))
        # Check for 422 (alias collision) before raise_for_status
        if response.status_code == 422:
            raise AliasCollisionError(f"Alias '{custom_alias}' already exists")
        response.raise_for_status()
        data = response.json()

        if data["code"] == 0:
            return data["data"]["tiny_url"]
        else:
            print(f"Error from TinyURL API: {data['errors']}")
            return None

    except AliasCollisionError:
        raise  # Re-raise collision errors for handling upstream
    except requests.exceptions.RequestException as e:
        print(f"Request error: {e}")
        return None
    except ValueError as e:
        print(f"JSON decoding error: {e}")
        return None


# --- Gemini Functions ---
def shorten_with_gemini(text: str, api_key: str, max_length: int = 15) -> str:
    """Shortens text using Google's Gemini API.

    Args:
        text: The text to shorten.
        api_key: Your Google Gemini API key.
        max_length: The desired maximum length of the shortened text.

    Returns:
        The shortened text, or None if an error occurs.
    """
    client = genai.Client(api_key=api_key)

    try:
        response = client.models.generate_content(
            model="gemini-2.5-flash",
            contents=f"""Create a very short URL slug (max {max_length} chars) for this Catholic meditation title:

"{text}"

Abbreviation rules:
- St = Saint, OL = Our Lady, BVM = Blessed Virgin Mary, Bl = Blessed
- Drop articles (the, a, of) and filler words
- Use only the core concept (e.g., "death" not "outlookondeath")
- Lowercase, no spaces/special chars

Output ONLY the slug, nothing else.""",
            config=types.GenerateContentConfig(
                system_instruction="You create ultra-short URL slugs. Be aggressive with abbreviation. Output only the slug.",
                temperature=1.0,
                max_output_tokens=1024,
            ),
        )

        shortened_text = response.text.strip()

        # Remove special characters and convert to lowercase
        shortened_text = re.sub(r"[^a-z\s]", "", shortened_text.lower())

        # Rate limiting delay to avoid hitting Gemini API quota
        time.sleep(GEMINI_RATE_LIMIT_DELAY)

        return shortened_text

    except Exception as e:
        print(f"Error shortening with Gemini: {e}")
        # Still apply delay on error to avoid rapid retries
        time.sleep(GEMINI_RATE_LIMIT_DELAY)
        return None


def extract_numbers_from_title(title: str) -> str:
    """Extracts significant numbers from a title (years, ordinals, etc.).

    Args:
        title: The title/slug to extract numbers from.

    Returns:
        A string containing extracted numbers, or empty string if none found.
    """
    numbers = []

    # Extract 4-digit years (e.g., 2023, 2024, 2025)
    years = re.findall(r'\b(20\d{2})\b', title)
    numbers.extend(years)

    # Extract ordinals (e.g., 1st, 2nd, 3rd, 4th, 21st)
    ordinals = re.findall(r'\b(\d+)(?:st|nd|rd|th)\b', title, re.IGNORECASE)
    numbers.extend(ordinals)

    # Extract standalone numbers not already captured (e.g., "part-2", "vol-3")
    standalone = re.findall(r'\b(\d{1,2})\b', title)
    for num in standalone:
        if num not in numbers:
            numbers.append(num)

    return ''.join(numbers)


# --- Combined Function ---
def create_custom_short_url(
    long_url: str, tinyurl_api_token: str, gemini_api_key: str, max_retries: int = 5
) -> str:
    """Creates a custom TinyURL with an alias generated by Gemini.

    Args:
        long_url: The long URL to shorten.
        tinyurl_api_token: Your TinyURL API token.
        gemini_api_key: Your Google Gemini API key.
        max_retries: Maximum number of retries on alias collision.

    Returns:
        The shortened URL, or None if an error occurred.
    """
    try:
        last_part = long_url.split("/")[-2]
    except IndexError:
        print(f"Invalid URL format: {long_url}")
        return None

    shortened_content = shorten_with_gemini(last_part, gemini_api_key)
    if not shortened_content:
        return None

    shortened_content = shortened_content.replace(" ", "")

    # Extract and append numbers from original title
    numbers = extract_numbers_from_title(last_part)
    if numbers:
        shortened_content = shortened_content + numbers

    print(f"Gemini Abbreviation: {shortened_content}")

    max_alias_length = 30
    prefix = "frcmed-"
    suffix = "-transcript"
    available_length = max_alias_length - len(prefix) - len(suffix)

    base_content = shortened_content[:available_length]

    for attempt in range(max_retries):
        if attempt == 0:
            # First attempt: use original abbreviation
            content = base_content
        else:
            # Subsequent attempts: add random suffix
            random_suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=3))
            # Truncate base to make room for suffix
            content = base_content[:available_length - 3] + random_suffix
            print(f"Retry {attempt}: trying {content}")

        custom_alias = f"{prefix}{content}{suffix}"

        try:
            short_url = shorten_url_tinyurl_api(
                long_url, tinyurl_api_token, custom_alias=custom_alias
            )
            return short_url
        except AliasCollisionError:
            if attempt < max_retries - 1:
                print(f"Alias collision, retrying...")
            else:
                print(f"Failed after {max_retries} attempts due to alias collisions")
                return None

    return None


def process_urls(
    long_urls: List[str], tinyurl_api_token: str, gemini_api_key: str
) -> List[Tuple[str, str]]:
    """Processes a list of URLs, creating custom shortened versions for each.

    Args:
        long_urls: A list of long URLs to shorten.
        tinyurl_api_token: Your TinyURL API token.
        gemini_api_key: Your Google Gemini API key.

    Returns:
        A list of tuples, where each tuple contains the original long URL and its corresponding shortened URL.
        If a URL fails to be shortened, its corresponding entry in the list will be (long_url, None).
    """
    results: List[Tuple[str, str]] = []
    for url in long_urls:
        short_url = create_custom_short_url(url, tinyurl_api_token, gemini_api_key)
        if short_url:
            print(f"Shortened URL for {url}: {short_url}")
            results.append(
                (url, short_url)
            )  # Add (long_url, short_url) tuple to results
        else:
            print(f"Failed to shorten {url}")
            results.append((url, None))  # Add (long_url, None) to indicate failure

    return results


def export_to_excel(
    results: List[Tuple[str, str]], output_path: str = None
) -> str:
    """Exports the URL shortening results to an Excel file.

    Args:
        results: A list of tuples containing (long_url, short_url).
        output_path: Optional path for the output file. If not provided,
                     a timestamped filename will be generated.

    Returns:
        The path to the created Excel file.
    """
    if output_path is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_path = f"shortened_urls_{timestamp}.xlsx"

    wb = Workbook()
    ws = wb.active
    ws.title = "Shortened URLs"

    # Add headers
    ws["A1"] = "Long URL"
    ws["B1"] = "Short URL"
    ws["C1"] = "Status"

    # Style headers (bold)
    for cell in ws[1]:
        cell.font = Font(bold=True)

    # Add data
    for row_idx, (long_url, short_url) in enumerate(results, start=2):
        ws[f"A{row_idx}"] = long_url
        ws[f"B{row_idx}"] = short_url if short_url else ""
        ws[f"C{row_idx}"] = "Success" if short_url else "Failed"

    # Adjust column widths
    ws.column_dimensions["A"].width = 60
    ws.column_dimensions["B"].width = 40
    ws.column_dimensions["C"].width = 10

    wb.save(output_path)
    print(f"Results exported to: {output_path}")
    return output_path


# --- Example Usage ---
if __name__ == "__main__":
    load_dotenv()
    gemini_api_key = os.getenv("GEMINI_API_KEY")
    tinyurl_api_token = os.getenv("TINYURL_API_TOKEN")

    long_urls = [
        "https://frconor-ebook.github.io/meditations/homilies/the-apostolate/",
    ]

    shortened_urls = process_urls(long_urls, tinyurl_api_token, gemini_api_key)

    # Export results to Excel
    export_to_excel(shortened_urls)

    # Print the results nicely:
    for long_url, short_url in shortened_urls:
        if short_url:
            print(f"{long_url} -> {short_url}")
        else:
            print(f"{long_url} -> Shortening Failed")
