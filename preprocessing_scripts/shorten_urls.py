import json
import os
import re
from typing import List, Tuple

import requests
from dotenv import load_dotenv
from groq import Groq


# --- TinyURL Functions ---
def shorten_url_tinyurl_api(
    long_url: str, api_token: str, custom_alias: str = None
) -> str:
    """Shortens a URL using the TinyURL API.

    Args:
        long_url: The long URL to shorten.
        api_token: Your TinyURL API token.
        custom_alias: (Optional) A custom alias for the URL.

    Returns:
        The shortened URL, or None if an error occurred.
    """
    api_url = "https://api.tinyurl.com/create"
    headers = {
        "Authorization": f"Bearer {api_token}",
        "Content-Type": "application/json",
    }

    payload = {"url": long_url, "domain": "tinyurl.com", "alias": custom_alias}

    try:
        response = requests.post(api_url, headers=headers, data=json.dumps(payload))
        response.raise_for_status()
        data = response.json()

        if data["code"] == 0:
            return data["data"]["tiny_url"]
        else:
            print(f"Error from TinyURL API: {data['errors']}")
            return None

    except requests.exceptions.RequestException as e:
        print(f"Request error: {e}")
        return None
    except ValueError as e:
        print(f"JSON decoding error: {e}")
        return None


# --- Groq Functions ---
def shorten_with_groq(text: str, api_key: str, max_length: int = 15) -> str:
    """Shortens text using Groq's chat completions API.

    Args:
        text: The text to shorten.
        api_key: Your Groq API key.
        max_length: The desired maximum length of the shortened text.

    Returns:
        The shortened text, or None if an error occurs.
    """
    client = Groq(api_key=api_key)

    try:
        chat_completion = client.chat.completions.create(
            messages=[
                {
                    "role": "system",
                    "content": "You are a helpful assistant that shortens text into concise, readable, lowercase summaries without special characters.",
                },
                {
                    "role": "user",
                    "content": (
                        f"Shorten the following text to a maximum of {max_length} characters. "
                        f"Provide a lowercase, contracted abbreviation of the following text, removing all special characters:\n\n{text}"
                    ),
                },
            ],
            model="llama-3.3-70b-versatile",
            temperature=1,  # Lower temperature for more focused output
            max_tokens=50,
            top_p=1,
            stop=None,
            stream=False,
        )

        shortened_text = chat_completion.choices[0].message.content.strip()

        # Remove special characters and convert to lowercase
        shortened_text = re.sub(r"[^a-z\s]", "", shortened_text.lower())

        return shortened_text

    except Exception as e:
        print(f"Error shortening with Groq: {e}")
        return None


# --- Combined Function ---
def create_custom_short_url(
    long_url: str, tinyurl_api_token: str, groq_api_key: str
) -> str:
    """Creates a custom TinyURL with an alias generated by Groq.

    Args:
        long_url: The long URL to shorten.
        tinyurl_api_token: Your TinyURL API token.
        groq_api_key: Your Groq API key.

    Returns:
        The shortened URL, or None if an error occurred.
    """
    try:
        last_part = long_url.split("/")[-2]
    except IndexError:
        print(f"Invalid URL format: {long_url}")
        return None

    shortened_content = shorten_with_groq(last_part, groq_api_key)
    if not shortened_content:
        return None

    shortened_content = shortened_content.replace(" ", "")  #
    print(f"Groq Abbreviation: {shortened_content}")

    max_alias_length = 30
    prefix = "frcmed-"
    suffix = "-transcript"
    available_length = max_alias_length - len(prefix) - len(suffix)

    shortened_content = shortened_content[:available_length]
    custom_alias = f"{prefix}{shortened_content}{suffix}"

    short_url = shorten_url_tinyurl_api(
        long_url, tinyurl_api_token, custom_alias=custom_alias
    )

    return short_url


# --- Main Function for Processing Multiple URLs ---
from typing import List, Tuple

# ... (other functions: shorten_url_tinyurl_api, shorten_with_groq, create_custom_short_url)


def process_urls(
    long_urls: List[str], tinyurl_api_token: str, groq_api_key: str
) -> List[Tuple[str, str]]:
    """Processes a list of URLs, creating custom shortened versions for each.

    Args:
        long_urls: A list of long URLs to shorten.
        tinyurl_api_token: Your TinyURL API token.
        groq_api_key: Your Groq API key.

    Returns:
        A list of tuples, where each tuple contains the original long URL and its corresponding shortened URL.
        If a URL fails to be shortened, its corresponding entry in the list will be (long_url, None).
    """
    results: List[Tuple[str, str]] = []
    for url in long_urls:
        short_url = create_custom_short_url(url, tinyurl_api_token, groq_api_key)
        if short_url:
            print(f"Shortened URL for {url}: {short_url}")
            results.append(
                (url, short_url)
            )  # Add (long_url, short_url) tuple to results
        else:
            print(f"Failed to shorten {url}")
            results.append((url, None))  # Add (long_url, None) to indicate failure

    return results


# --- Example Usage ---
if __name__ == "__main__":
    load_dotenv()
    groq_api_key = os.getenv("GROQ_API_KEY")
    tinyurl_api_token = os.getenv("TINYURL_API_TOKEN")

    long_urls = [
        "https://frconor-ebook.github.io/meditations/homilies/the-apostolate/",
    ]

    shortened_urls = process_urls(long_urls, tinyurl_api_token, groq_api_key)

    # Print the results nicely:
    for long_url, short_url in shortened_urls:
        if short_url:
            print(f"{long_url} -> {short_url}")
        else:
            print(f"{long_url} -> Shortening Failed")
